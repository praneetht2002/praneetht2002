
#import neccessary modules
from sklearn.cluster import KMeans
import numpy as np
import matplotlib.pyplot as plt
import pandas as ps
import warnings
import os
warnings.filterwarnings('ignore')

# x1=np.array([3, 1, 1, 2, 1, 6, 6, 6, 5, 6,7, 8, 9, 8, 9, 9, 8, 4, 4, 5, 4])     #dataset
# x2=np.array([5, 4, 5, 6, 5, 8, 6, 7, 6, 7, 1, 2, 1, 2, 3, 2, 3, 9, 10, 9, 10])
# x=np.array(list(zip(x1,x2)))

#data preprocessing
data=ps.read_csv("D:\Major project\city_dataset.csv")
x=data.iloc[:,[1,2]].values

K =range(1,10)
inertias=[]

#finding the number of clusters using elbow method
for k in K:
    kmeans=KMeans(n_clusters=k)
    kmeans.fit(x)
    inertias.append(kmeans.inertia_)

#plot the wcss(inertia_values) vs number of clusters(1-10)
plt.plot(K,inertias)
plt.savefig(os.path.join("D://Major project","elbow_curve.png"))
plt.show()
no_clust=int(input("Enter the number of clusters :-"))

#based on the number of clusters given by elbow curve(above) perform the K-means clustering
kmeans=KMeans(n_clusters=no_clust,init='k-means++',random_state=42)
y_kmeans=kmeans.fit_predict(x)
print(y_kmeans,x)
#It's time to visualize the clusters generated by the kmeans model
colors = np.array(["red","green","blue","yellow","pink","black","orange","purple","beige","brown","gray","cyan","magenta"])
for i in range(no_clust):
    plt.scatter(x[y_kmeans==i,0],x[y_kmeans==i,1],s=100,c=colors[i],label='cluster '+str(i))

    
plt.scatter(kmeans.cluster_centers_[:,0],kmeans.cluster_centers_[:,1],s=200,c=colors[no_clust],label='centroid')

plt.title("segmentation of customers dataset")
plt.xlabel("Annual Income")
plt.ylabel("Spending Score")
plt.legend()
plt.savefig(os.path.join("D://Major project","clusters.png"))

plt.show()



#Evaluation of KMeans

from yellowbrick.cluster import SilhouetteVisualizer
from sklearn import metrics
fig,ax=plt.subplots(2,2,figsize=(15,8))
k=2
for i in [no_clust-1,no_clust,no_clust+1,no_clust+2]:
    km=KMeans(n_clusters=i,init='k-means++',n_init=10,max_iter=100,random_state=42)
    q,mod=divmod(k,2)
    visualizer=SilhouetteVisualizer(km,colors='yellowbrick',ax=ax[q-1][mod])
    visualizer.fit(x)
    km.fit(x)
    score=metrics.silhouette_score(x,km.labels_,metric='euclidean')
    ax[q-1][mod].set_title("Score:"+str(score))
    k=k+1
fig.suptitle("Evaluation of KMeans using Silhouette score ")
plt.show()
